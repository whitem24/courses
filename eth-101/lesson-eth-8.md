# DAPP Front-end

For our DAPP (decentralized app) we will be using React and Ethers.js to build the front-end for our Bank contract that we built in the previous lesson. You can view the final version of our project [here](https://cadena-bank-dapp.vercel.app/) and play around with it using the Rinkeby network. You can find the repo with the completed code for reference [here](https://github.com/saeedjabbar/cadena-bank-dapp).

Ethers is a javascript library that helps us interact with our smart contract and the ethereum blockchain. React is a front-end library commonly used for dapp interfaces. If you don't know React that's fine, these principles apply to other front-end frameworks as well and I will be providing the React code and styling for you. If you would like a quick 101 of React, check this [out](https://create-react-app.dev/docs/getting-started). While this isn't a course on React, I will provide a high level overview of certain React concepts so those who aren't familiar with React can follow along.

![](https://cadena.incl.us/wp-content/uploads/2021/12/cadena-dapp-bank-project-rz.png)

To help you get started quickly you can fork the repo for the boilerplate React project [here](https://github.com/CadenaDev/bank-dapp-boilerplate) to run locally. Below is the final version of the code we will be writing together and as usual we will be breaking it down for you. 

Note: Because the file is long I've only included a snippet, you can find the completed code for the App.js file [here](https://gist.github.com/saeedjabbar/a4d6d341f54613050e9726bacb265e79) and the completed project [here](https://github.com/saeedjabbar/cadena-bank-dapp). Before we begin, let's review the completed code to get a high level overview of what we're going to accomplish.

```javascript
import { useState, useEffect } from 'react';
import { ethers, utils } from "ethers";
import abi from "./contracts/Bank.json";

function App() {
  const [isWalletConnected, setIsWalletConnected] = useState(false);
  const [isBankerOwner, setIsBankerOwner] = useState(false);
  const [inputValue, setInputValue] = useState({ withdraw: "", deposit: "", bankName: "" });
  const [bankOwnerAddress, setBankOwnerAddress] = useState(null);
  const [customerTotalBalance, setCustomerTotalBalance] = useState(null);
  const [currentBankName, setCurrentBankName] = useState(null);
  const [customerAddress, setCustomerAddress] = useState(null);
  const [error, setError] = useState(null);

  const contractAddress = '0xf333875f89B62AA14e7E009114B707ae1ED3830b';
  const contractABI = abi.abi;
  const {ethereum} = window;
  
  ....Get Completed File Here: [https://gist.github.com/saeedjabbar/a4d6d341f54613050e9726bacb265e79]
```



## Setting Up Our Contract 

Before we dive into our code, let's think about the outcomes of our dapp. We will be getting information from our bank like acccount balances, completing transactions like deposits and withdrawals, and if we're the bank owner, setting up our bank. In order for a customer or bank owner to interact with our dapp, they will need an ethereum wallet that we will connect to.

```javascript
import { useState, useEffect } from 'react';
import { ethers, utils } from "ethers";
import abi from "./contracts/Bank.json";
```

Now let's jump into the first 3 lines. In our first line we're pulling some hooks from react but line 2 and 3 is most important for us. After installing the ethers.js package we're importing ethers and [utilities](https://docs.ethers.io/v5/api/utils/) from the ethers library. Then finally we're going to be importing the JSON version of our contract that was generated by Hardhat. The steps to do so are as follows: 

1. Create a folder called `contract` in your react project `src` folder, paste over your Bank.json file from our smart contract lesson in our hardhat project. The file is found in `./artifacts/contracts/Bank.sol/Bank.json`. It's commonly referred to as an Application Binary Interface (ABI) file and contains a JSON version of our contract that we can interface with.
2. Import your ABI file into your project using `import abi from "./contracts/Bank.json";`

I'm going to briefly explain what's happening here. The first item in the array is a state variable we use to store values we reference later using the React `useState()` [hook](https://reactjs.org/docs/hooks-state.html). The second item is a function that lets us change our state. The parameters of the `useState()` function are our default values, ie. our wallet connection status is set to false by default.

```javascript
const [isWalletConnected, setIsWalletConnected] = useState(false);
const [isBankerOwner, setIsBankerOwner] = useState(false);
const [inputValue, setInputValue] = useState({ withdraw: "", deposit: "", bankName: "" });
const [bankOwnerAddress, setBankOwnerAddress] = useState(null);
const [customerTotalBalance, setCustomerTotalBalance] = useState(null);
const [currentBankName, setCurrentBankName] = useState(null);
const [customerAddress, setCustomerAddress] = useState(null);
const [error, setError] = useState(null);
```

Now for the important parts. Grab the address of your contract, this was given to you in Hardhat when you deployed your contract. In line 1 we create a variable to store the address of our contract. In line two we are grabbing the abi file we imported using a reference variable and getting the actual ABI project off of it, then storing that in a varible called `contractABI`, take look at your Bank.json file to see what I mean, or see [this screen shot](https://cadena.incl.us/wp-content/uploads/2021/12/abi.png) for a reference.

```javascript
const contractAddress = '0xf333875f89B62AA14e7E009114B707ae1ED3830b';
const contractABI = abi.abi;
```

ðŸš¨**Note:** Everytime you make a change in your smart contract and deploy it, there will be a new address and abi file generated. You have to copy over the new contract address and abi file into your React project. If you find yourself pulling your hair out because your dapp or smart contract isn't working, many times it's because you haven't updated your contract address and abi to the latest versions.ðŸš¨

## Connecting to MetaMask 

Now we have to see if our user has an Ethereum wallet in this case MetaMask and if that wallet exists connect it to our DAPP. It's the equivalent of using and connecting to an app with an Auth service provider like Facebook Connect. Without a wallet the user will not be able to fully interact with "web3".

You can use a library like [Web3Modal](https://github.com/Web3Modal/web3modal) to connect to the most popular Ethereum Wallets but we're keeping this simple for this course. Note: Most of our functions are async since we're awaiting values to be returned.

```javascript
const checkIfWalletIsConnected = async () => {
  try {
    if (ethereum) {
      const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
      const account = accounts[0];
      setIsWalletConnected(true);
      setCustomerAddress(account);
      console.log("Account Connected: ", account);
    } else {
      setError("Please install a MetaMask wallet to use our bank.");
      console.log("No Metamask detected");
    }
  } catch (error) {
    console.log(error);
  }
}
```

Ethereum wallets usually come in the form of browser extensions and when installed they will inject a global variable called ethereum into the window object. On `line 3` we check if ethereum is in the window object (ethereum) which means a wallet is likely present. On `line 4` we're making a request to get an array of metamask accounts and `line 5` we're grabbing the first account at index 0, which is the current connected account. On `line 6` we set our wallet is connected to true, which will render the web3 functionalities of our dapp that we gated. Then on `line 7` we store the current connected address in state.

`checkIfWalletIsConnected()` is being loaded as soon as our app loads via the useEffect() hook at line [179](https://gist.github.com/saeedjabbar/a4d6d341f54613050e9726bacb265e79#file-app-js-L179).  You can read more details about this process in the official MetaMask [docs](https://docs.metamask.io/guide/getting-started.html#basic-considerations).

## Getter Functions

```javascript

const getContract = (ethereum) => {
    const provider = ethers.providers.Web3Provider(ethereum);
    const signer = provider.getSigner();
    const bankContract = new ethers.Contract(contractAddress, contractABI, signer);
    return bankContract;
  }

```
Before we check our first getter function let's see the getContract function. Let's break down line by line. 

```javascript
const provider = new ethers.providers.Web3Provider(ethereum);
```

A provider lets us connect to the ethereum blockchain, in this case the Rinkeby testnet via an ethereum node. We're using MetaMask's provider which uses [Infura](https://infura.io/) behind the scenes. You can read more about providers [here](https://docs.ethers.io/v5/api/providers/#:~:text=A%20Provider%20is%20an%20abstraction,to%20standard%20Ethereum%20node%20functionality.). It's important to know providers that can only complete read-only actions.

![Credit: StackExchange](https://cadena.incl.us/wp-content/uploads/2021/12/providers.png)

```javascript
const signer = provider.getSigner();
```

Now with our provider we get a signer which is an abtraction of your MetaMask wallet that lets you interact with the blockchain without revealing your private keys. As a signer, you can write to the ethereum blockchain via transactions. You can read more on signers [here](https://docs.ethers.io/v5/api/signer/#:~:text=A%20Signer%20in%20ethers%20is,on%20the%20sub%2Dclass%20used.).

```javascript
const bankContract = new ethers.Contract(contractAddress, contractABI, signer);
```

Next we get our contract using our contract address, the ABI file, and a signer. 

```javascript

const getBankName = async () => {
  try {
    if (ethereum) {
      const bankContract = getContract(ethereum);
      let bankName = await bankContract.bankName();
      bankName = utils.parseBytes32String(bankName);
      setCurrentBankName(bankName.toString());
    } else {
      console.log("Ethereum object not found, install Metamask.");
      setError("Please install a MetaMask wallet to use our bank.");
    }
  } catch (error) {
    console.log(error);
  }
}
```
Now let's look at the first of our getter functions. Remember calling a getter fuction is free (it costs no gas), since it's read only. Again we're checking if the ethereum object is present at `line 3`. Let's break down lines 5 through 7.

```javascript
let bankName = await bankContract.bankName();
bankName = utils.parseBytes32String(bankName);
setCurrentBankName(bankName.toString());
```

We then get the name of our bank by calling the public bankName variable we had set up in our [smart contract](https://gist.github.com/saeedjabbar/8df7a329edbb92274bf1f08c8cf55ee9#file-bankcontract-sol-L7). Remember, by using the public keyword in our smart contract, we automatically get a getter fuction. Using the `parseBytes32String()` we convert our bankName to a readable string and then set it as our current bank name using `setCurrentBankName` where the type of string is enforced using toString. 

**Note:** There will be no bank name unless you're the owner account that sets it. You can do this by logging into MetaMask with the account you used to deploy the contract and then using the setter function in the next step.

## Setter Functions 

```javascript
const setBankNameHandler = async (event) => {
    event.preventDefault();
    try {
      if (ethereum) {
        const bankContract = getContract(ethereum);

        const txn = await bankContract.setBankName(utils.formatBytes32String(inputValue.bankName));
        console.log("Setting Bank Name...");
        await txn.wait();
        console.log("Bank Name Changed", txn.hash);
        await getBankName();

      } else {
        console.log("Ethereum object not found, install Metamask.");
        setError("Please install a MetaMask wallet to use our bank.");
      }
    } catch (error) {
      console.log(error);
    }
  }
```

Next let's look at our setter functions, which cost gas and require a signer to initiate them. We've covered lines 4 through 7 but I quickly want to touch on line 2 for those who aren't familiar with React. `event.preventDefault() ` prevents our dapp from reloading everytime we submit our form. Remember to use the wallet that you used to deploy your contract with to set your bank name, as you need to be the owner of the contract to do so. You will see this special section to set your bank name only if you're the contract owner:

![](http://cadena.incl.us/wp-content/uploads/2021/12/cadena-admin-panel-rz.png)

```javascript
const txn = await bankContract.setBankName(utils.formatBytes32String(inputValue.bankName));
console.log("Setting Bank Name...");
await txn.wait();
console.log("Bank Name Changed", txn.hash);
getBankName();
```

After we retrieve our contract, in `line 1` we then call our setBankName from our contract, reference [here](https://gist.github.com/saeedjabbar/8df7a329edbb92274bf1f08c8cf55ee9#file-bankcontract-sol-L19). We format the value from our input form to a byte32 string. In `line 3`, we wait for our transaction to resolve, note it can take sometime, event on a testnet. Then finally once our transaction is resolved, we `console.log` the hash which you can put in Etherscan to see the details of your transaction. Finally, we call the getBankName function to update the name of our bank in our dapp. The remaining getter and setter functions follow a similar pattern to the two we covered above.

## Bank Owner

Next lets look at the `getBankOwnerHandler()` function. I will be skipping the repetive parts that we covered in the previous examples. 

```javascript
  const getbankOwnerHandler = async () => {
    try {
      if (ethereum) {
        const bankContract = getContract(ethereum);
        
        let owner = await bankContract.bankOwner();
        setBankOwnerAddress(owner);

        const [account] = await ethereum.request({ method: 'eth_requestAccounts' });

        if (owner.toLowerCase() === account.toLowerCase()) {
          setIsBankerOwner(true);
        }
      } else {
        console.log("Ethereum object not found, install Metamask.");
        setError("Please install a MetaMask wallet to use our bank.");
      }
    } catch (error) {
      console.log(error);
    }
  }
```

```javascript
let owner = await bankContract.bankOwner();
setBankOwnerAddress(owner);

const [account] = await ethereum.request({ method: 'eth_requestAccounts' });

if (owner.toLowerCase() === account.toLowerCase()) {
  setIsBankerOwner(true);
}
```

In `line 1` we're calling our contract to get the address of the bank owner, remember we stored that in a public variable in our contract [here](https://gist.github.com/saeedjabbar/8df7a329edbb92274bf1f08c8cf55ee9#file-bankcontract-sol-L6). Next we're getting the current Ethereum account on line 4. Then in line 6, we're checking to see if the current MetaMask Wallet address matches the address that deployed and owns the contract. If that is the case, we use `setIsBankerOwner` to set our bank owner flag to true and show the special admin panel.

## Customer Balance

```javascript
  const customerBalanceHandler = async () => {
    try {
      if (ethereum) {
        const bankContract = getContract(ethereum);

        let balance = await bankContract.getCustomerBalance();
        setCustomerTotalBalance(utils.formatEther(balance));
        console.log("Retrieved balance...", balance);

      } else {
        console.log("Ethereum object not found, install Metamask.");
        setError("Please install a MetaMask wallet to use our bank.");
      }
    } catch (error) {
      console.log(error)
    }
  }
```

To get the balance we're calling the getCustomerBalance() function in our smart contract and then on `line 9` we're setting that balance so we can display it to the user. Most importantly we're formatting it in Ether using `utils.formatEther()`.

## Depositing Money

```javascript
  const deposityMoneyHandler = async (event) => {
    try {
      event.preventDefault();
      if (ethereum) {
        const bankContract = getContract(ethereum);

        const txn = await bankContract.depositMoney({ value: ethers.utils.parseEther(inputValue.deposit) });
        console.log("Deposting money...");
        await txn.wait();
        console.log("Deposited money...done", txn.hash);

        customerBalanceHandler();

      } else {
        console.log("Ethereum object not found, install Metamask.");
        setError("Please install a MetaMask wallet to use our bank.");
      }
    } catch (error) {
      console.log(error)
    }
  }
```

We're depositing money into our contract. As usual with a transaction function it will cost gas but notice on line 9 we're using the `utils.parseEther()` function to convert our Eth back into wei for our smart contract. After the transaction is completed we call our `customerBalanceHandler()` to update the balance of our account.

ðŸš¨Note: Test with small amouts of Eth (0.01) in the event you get an error regarding not having enough for gas.ðŸš¨



## Withdraw Money

```javascript
  const withDrawMoneyHandler = async (event) => {
    try {
      event.preventDefault();
      if (ethereum) {
        const bankContract = getContract(ethereum);

        let myAddress = await signer.getAddress()
        console.log("provider signer...", myAddress);

        const txn = await bankContract.withDrawMoney(myAddress, ethers.utils.parseEther(inputValue.withdraw));
        console.log("Withdrawing money...");
        await txn.wait();
        console.log("Money with drew...done", txn.hash);

        customerBalanceHandler();

      } else {
        console.log("Ethereum object not found, install Metamask.");
        setError("Please install a MetaMask wallet to use our bank.");
      }
    } catch (error) {
      console.log(error)
    }
  }
```

Lastly we withdraw money back to our wallet and update our balance. Notice we're also parsing Ether to wei here as well using `utils.parseEther()`. 

ðŸš¨Note: Test with small amouts of Eth (0.01) in the event you get an error regarding not having enough for gas.ðŸš¨

## Wrapping Up

```javascript
  const handleInputChange = (event) => {
    setInputValue(prevFormData => ({ ...prevFormData, [event.target.name]: event.target.value }));
  };

  useEffect(() => {
    checkIfWalletIsConnected();
    getBankName();
    getbankOwnerHandler();
    customerBalanceHandler()
  }, [isWalletConnected]);
```

`handleInputChange()` lets us grab the value from our form inputs and pass it to our handler functions. `useEffect()` is a React [hook](https://reactjs.org/docs/hooks-effect.html) that loads up all of our functions when the dapp first loads, then if the wallet connection status changes it will reload the functions inside of it. It does this by watching for changes in`isWalletConnected`. The remaining HTML with the styling and handler functions can be found [here](https://gist.github.com/saeedjabbar/b8aa41672a9fd0c89f22e766c1e6e896).

Next up is our first project which builds off of the concepts you learned here and will help reinforce them. Keep moving on even if everything doesn't click at first, by the time you're finished with this course, the pieces will come together and things will start to click. If you have any questions, feel free to let us know in Discord.

Give your self a huge congratulations for making it this far. Feel free to deploy your app on Github pages, Vercel, or your favorite hosting platform and share it in the chat ðŸŽ‰

Note: If you run into an error with Vercel when deploying [here's](https://dev.to/rabihcigar/treating-warnings-as-errors-because-process-env-ci-true-22i4) the fix.
